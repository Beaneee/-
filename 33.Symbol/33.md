## `Symbol` 이란?


> ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 주로 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다.
>

## `Symbol` 값의 생성


### 1. `Symbol` 함수

- `Symbol` 함수를 호출하여 생성한다. 다른 원시값들과는 달리 리터럴 표기법으로 값을 생성할 수 없다.
- 외부로 노출되지 않아 값을 확인할 수 없으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다.

```jsx
const mySymbol = Symbol();

console.log(typeof mySymbol); // symbol

console.log(mySymbol); // Symbol()
```

- `new` 연산자와 함께 호출하지 않는다. `new` 연산자와 함께 생성자 함수 또는 클래스를 호출하면 객체가 생성되지만 `Symbol` 은 변경 불가능한 원시 값이다.

```jsx
new Symbol(); // TypeError: Symbol is not a constructor
```

- `Symbol` 은 암묵적으로 `String` 이나 `Number` 타입으로 변환되지 않는다.

```jsx
const mySymbol = Symbol();

console.log(mySymbol + ''); // TypeError: Cannot convert a Symbol value to string
console.log(+mySymbol); // TypeError: Cannot convert a Symbol value to number
```

- 단, `boolean` 타입으로는 암묵적으로 타입 변환된다.

```jsx
const mySymbol = Symbol();

console.log(!!mySymbol); // true
```

### 2. `Symbol.for` / `Symbol.keyFor` 메서드

- `Symbol.for` 는 인수로 전달받은 문자열을 키로 사용하여 키와 심벌 값의 쌍들이 저장되어 있는 전역 심벌 레지스트리에서 해당 키와 일치하는 심벌 값을 검색한다.

```jsx
// 저장된 심벌 값이 없으면 새로운 심벌 값을 생성
const s1 = Symbol.for('mySymbol');

// 저장된 심벌 값이 있으면 심벌 값을 반환
const s2 = Symbol.for('mySymbol');

console.log(s1 === s2); // true
```

- `Symbol.keyFor` 는 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출할 수 있다.

```jsx
const s1 = Symbol.for('mySymbol');

Symbol.keyFor(s1); // mySymbol
```