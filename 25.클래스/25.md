## 클래스의 정의


```jsx
//클래스 선언문
class Person {}
```

- 클래스 몸체에는 0개 이상의 메서드만 정의할 수 있다. 정의할 수 있는 메서드는 constructor, 프로토타입 메서드, 정적 메서드가 있다.

```jsx
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드
  static sayHello() {
    console.log('Hello!');
  }
}

// 인스턴스 생성
const me = new Person('Lee');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// 정적 메서드 호출
Person.sayHello(); // Hello!
```

![https://velog.velcdn.com/images/kozel/post/0a777603-e6fa-4f55-a067-ce99a6d458b1/image.jpeg](https://velog.velcdn.com/images/kozel/post/0a777603-e6fa-4f55-a067-ce99a6d458b1/image.jpeg)

## 클래스 호이스팅


> 클래스 선언문으로 정의한 클래스는 함수 선언문과 같이 소스코드 평가 과정, 즉 런타임 이전에 먼저 평가되어 함수 객체를 생성한다. 이 때 클래스가 평가되어 생성된 함수 객체는 생성자 함수로서 호출할 수 있는 함수, 즉 constructor다.
>

```jsx
console.log(Person);
// ReferenceError: Cannot access 'Person' before initialization

class Person {}
```

클래스는 `let`, `const` 와 같이 호이스팅이 일어나지 않는 것 처럼 보인다.

하지만 `let`, `const` 와 같이 TDZ에 빠지기 때문에 호이스팅이 발생하지 않는 것 처럼 보이는 것 뿐이다.

```jsx
const Person = '';

{
  // 호이스팅이 발생하지 않는다면 ''이 출력되어야 한다.
  console.log(Person);
  // ReferenceError: Cannot access 'Person' before initialization

  // 클래스 선언문
  class Person {}
}
```

## 인스턴스 생성


클래스는 생성자 함수이며 `new` 연산자와 함꼐 호출되어 인스턴스를 생성한다.

```jsx
class Person {}

const me = new Person();
console.log(me); // Person {}
```

클래스의 존재 이유는 인스턴스를 생성하는 것이다. 따라서 반드시 `new` 연산자와 함께 호출해야 한다.

```jsx
class Person {}

// 클래스를 new 연산자 없이 호출하면 타입 에러가 발생한다.
const me = Person();
// TypeError: Class constructor Person cannot be invoked without 'new'
```